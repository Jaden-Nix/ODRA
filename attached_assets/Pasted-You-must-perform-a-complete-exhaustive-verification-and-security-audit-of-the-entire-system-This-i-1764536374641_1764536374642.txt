You must perform a complete, exhaustive verification and security audit of the entire system.
This includes: smart contracts, ODRA logic, EVM-to-WASM mapping, bridge logic, AI modules, RPC endpoints, deployment flow, and frontend interactions.
You must not assume ANYTHING ‚Äî you must validate every single component through internal reasoning, code reconstruction, execution simulation, and dependency mapping.

üî• Your Tasks (MANDATORY):

1. FULL FEATURE VERIFICATION

For every module, confirm with explicit proof that it:
	‚Ä¢	exists
	‚Ä¢	compiles
	‚Ä¢	deploys
	‚Ä¢	initializes correctly
	‚Ä¢	stores state properly
	‚Ä¢	updates state correctly
	‚Ä¢	handles edge cases
	‚Ä¢	returns correct values
	‚Ä¢	interacts properly with all other modules
	‚Ä¢	works on live Casper Testnet

You must verify:
	‚Ä¢	ODRA-EVM abstraction
	‚Ä¢	Solidity‚ÜíWasm pipeline
	‚Ä¢	Casper RPC integration
	‚Ä¢	Contract deployer
	‚Ä¢	ERC-20 demo contract
	‚Ä¢	cCSPR Staking LST contract
	‚Ä¢	reward engine
	‚Ä¢	withdrawal logic
	‚Ä¢	bridge wrapper
	‚Ä¢	cross-chain send
	‚Ä¢	cross-chain receive
	‚Ä¢	dashboard RPC
	‚Ä¢	AI assistant modules
	‚Ä¢	logging + telemetry
	‚Ä¢	wallet signer
	‚Ä¢	frontend ‚Üî backend integration

If ANY feature is missing, incomplete, silent-failing, or partially implemented:
You must identify it, explain it, fix it, output corrected code, reintegrate it, and re-verify.

‚∏ª

2. FULL SECURITY AUDIT (MANDATORY)

You must perform a complete security vulnerability assessment using expert-level reasoning.

Audit EVERY contract, module, function, and endpoint for:
	‚Ä¢	reentrancy
	‚Ä¢	underflow/overflow
	‚Ä¢	integer precision bugs
	‚Ä¢	race conditions
	‚Ä¢	rebase inconsistencies
	‚Ä¢	cross-chain spoofing
	‚Ä¢	signature forgery
	‚Ä¢	flash loan abuse
	‚Ä¢	staking manipulation
	‚Ä¢	front-running
	‚Ä¢	withdrawal exploits
	‚Ä¢	malicious input vectors
	‚Ä¢	unbounded loops
	‚Ä¢	storage collision
	‚Ä¢	gas griefing
	‚Ä¢	bad randomness
	‚Ä¢	oracle manipulation
	‚Ä¢	bridge replay attacks
	‚Ä¢	bridge desync
	‚Ä¢	privilege escalation
	‚Ä¢	upgrade vulnerabilities
	‚Ä¢	unchecked external calls
	‚Ä¢	unauthenticated access
	‚Ä¢	staticcall bypass
	‚Ä¢	improper error handling
	‚Ä¢	emergency shutdown exploits

For each vulnerability found:
	1.	Name the vulnerability
	2.	Explain how it can be exploited
	3.	Explain the severity (Low / Medium / High / Critical)
	4.	Output the corrected code
	5.	Reintegrate the fix
	6.	Re-verify the entire system

‚∏ª

3. FULL RELIABILITY + FAILURE TESTING

Simulate:
	‚Ä¢	heavy transaction load
	‚Ä¢	rapid stake/unstake cycles
	‚Ä¢	bridge spam
	‚Ä¢	malformed packets
	‚Ä¢	incorrect signatures
	‚Ä¢	missing fields
	‚Ä¢	extreme edge cases
	‚Ä¢	gas starvation
	‚Ä¢	hash mismatches
	‚Ä¢	out-of-order execution
	‚Ä¢	UI desync
	‚Ä¢	RPC inaccessibility

Your job is to identify:
	‚Ä¢	ALL possible failure points
	‚Ä¢	ALL uncaught exceptions
	‚Ä¢	ALL situations that could break the system
	‚Ä¢	ALL logic that isn‚Äôt fully future-proof

Then:
	‚Ä¢	fix them
	‚Ä¢	output the updated code
	‚Ä¢	re-verify

‚∏ª

4. OUTPUT REQUIREMENTS (MANDATORY)

Your final output MUST include:

A. ‚ÄúFeature Validation Report‚Äù
List every feature and confirm ‚ÄúWORKING 100% VERIFIED‚Äù.

B. ‚ÄúSecurity Vulnerability Report‚Äù
List every vulnerability found + fixed.

C. ‚ÄúFinal Integration Report‚Äù
Confirm all contracts and modules interact correctly.

D. ‚ÄúCasper Testnet Verification Report‚Äù
Confirm all contracts are fully deployed and callable.

E. THE FINAL CERTIFICATE
If everything is perfect after all fixes, print:

üü© ‚ÄúALL SYSTEMS 100% VERIFIED ‚Äî ZERO VULNERABILITIES ‚Äî READY FOR CASPER HACKATHON.‚Äù

If not perfect, continue until it is.
